Ich w√ºrde gerne im bestehenden Projekt ein neues Feature prototypen. Mir w√§re es wichtig, dass ich jederzeit zur√ºck zu diesem Punkt kann und das Feature in einer Config einschalten und ausschalten kann. 

Ich habe einen Plan erstellt, mit dem wir mein neues Feature schrittweise implementieren k√∂nnen. 

Ich beschreibe dir jetzt wie das Feature aussehen soll und √ºberreiche dir den Plan. Anschlie√üend kommuniziere mit mir verst√§ndlich und schrittweise √ºber deine Entwicklungsprozesse. 


# Textuelle Beschreibung 

Es soll eine neue Seite geben, die von #file:PersonalizationPage.jsx √ºber einen Button "LLM Prototyp" erreichbar ist. Auf der neu erstellten Seite "LLMFeedbackPrototype" soll eine Applikation erstellt werden, mit der Sch√ºler*innen sich von einer KI Feedback generieren lassen k√∂nnen. Der Prompt, der vom Backend zur Musik generiert wird soll hier genutzt werden, um in Segmente aufgeteiltes Feedback √ºber eine LLM API zu generieren und in passenden Chats darzustellen und Nachfragen zu erlauben. 

Beschreibung des UX: 
Das Design der neuen Seite soll sich nahtlos an die anderen Seiten anschlie√üen und die selben Farb- und Layout-Konzepte nutzen. 

Unten, zentral ist ein Audio-Player f√ºr die Referenz-Audio-Datei, √ºber den man die Musik anh√∂ren kann. Direkt dadr√ºber liegt eine Reihe von Buttons. Die Buttons sind √ºber die Audio-Spur gelegt. Die Breite jedes Buttons ist abh√§ngig von der Anzahl der errechneten Segmente im Prompt (Backend-Logik) der Referenz-Datei. Durch das klicken jedes Buttons √∂ffnet man innerhalb einen Chat-Fenster-Containers die zum Segment zugeh√∂rigen LLM-Chats. Die Buttons sind farblich gekennzeichnet und dar√ºber mit einem Emoji versehen. Die Farbe ist abh√§ngig vom Feedback (gr√ºner Button + lachender Emoji = gutes Feedback; orangener Button + neutraler Emoji = neutral teilweise gut und schlecht; roter Button + trauriger Emoji = kritisches Feedback). Das LLM soll diese Farben und Emojis ausw√§hlen je nach dem wie das Feedback aussieht. 

Das LLM-Chatfenster liegt √ºber dem Audio-Player und den Buttons+ Emojis.

Das LLM-Chatfenster ist ein klassischer Content-Container (dunkelgrau, transparenter Hintergrund). Die Nachrichten vom Chatbot sind auf der linken Seite, dar√ºber findet man den Namen (MuDiKo-KI-Assistent) Entlang der Nachricht des Chatbots soll eine vertikale Linie in Farbe des Feedbacks erfolgen (rot, orange, gr√ºn). Die Antwort der Sch√ºler auf der rechten Seite, dar√ºber der Name (Erstmal nur "Sch√ºler"). Beim Sch√ºler h√§tte ich gerne eine vertikale Linie entlang der Nachrichten in Mudiko-pink. Die Nachrichten sind in einem hellgrauen Container mit wei√üer Schrift und klassischem Schatten. Wie in einem klassischen Chatfenster hat der User die M√∂glichkeit mit dem Assistenten zu chatten. Das Chatfenster sollt einen eigenen Scroller an der Seite haben. 

Ich brauche einen √ºbergreifenden Prompt durch den die KI versteht, was sie machen muss und um ein √ºber die ermittelten Segmente √ºbergreifendes Feedback zu ermitteln: Overall-Prompt zur Generierung von Segment Prompts.




# LLM Feedback Prototyp - Implementierungsplan

## 1. Feature Configuration
- [ ] Feature-Flag in einer zentralen Config-Datei erstellen
- [ ] Toggle-Mechanismus f√ºr einfaches Ein-/Ausschalten
- [ ] Fallback auf urspr√ºngliche Funktionalit√§t wenn deaktiviert

## 2. UI/UX Struktur

### 2.1 PersonalizationPage Erweiterung
- [ ] Button "LLM Prototyp" hinzuf√ºgen (nur sichtbar wenn Feature-Flag aktiv)
- [ ] Navigation zur neuen LLMFeedbackPrototype Seite
- [ ] Bestehende Funktionalit√§t unver√§ndert lassen

### 2.2 Neue Seite: LLMFeedbackPrototype
**Layout-Struktur (von oben nach unten):**
1. Header mit Titel und MuDiKo Logo (konsistent mit anderen Seiten)
2. Chat-Container (scrollbar, √ºber Audio-Player positioniert)
3. Segment-Buttons-Container (√ºber Audio-Spur gelegt)
4. Audio-Player (Referenz-Audio-Datei)
5. Navigation (Zur√ºck-Button)

## 3. Backend-Integration

### 3.1 Prompt-Analyse-Endpoint
- [ ] Endpoint zur Analyse des generierten Prompts
- [ ] Segmentierung der Audio-Datei basierend auf Prompt-Inhalt
- [ ] R√ºckgabe: Anzahl Segmente, Zeitstempel, Segment-Beschreibungen

### 3.2 LLM-Integration
- [ ] Overall-Prompt f√ºr Segment-basiertes Feedback
- [ ] Segment-spezifische Prompts basierend auf Musik-Analyse
- [ ] Feedback-Bewertung (gut/neutral/kritisch) f√ºr Farb-/Emoji-Zuordnung
- [ ] Chat-Funktionalit√§t f√ºr Nachfragen

## 4. Audio-Player Komponente
- [ ] Integration der Referenz-Audio-Datei
- [ ] Play/Pause/Seek Funktionalit√§t
- [ ] Synchronisation mit Segment-Buttons
- [ ] Responsive Design f√ºr mobile Ger√§te

## 5. Segment-Buttons System

### 5.1 Button-Generierung
- [ ] Dynamische Button-Erstellung basierend auf Segment-Anzahl
- [ ] Breiten-Berechnung: 100% / Anzahl Segmente
- [ ] Positionierung √ºber Audio-Player

### 5.2 Feedback-Visualisierung
- [ ] Farb-System: Gr√ºn (gut), Orange (neutral), Rot (kritisch)
- [ ] Emoji-System: üòä (gut), üòê (neutral), üòü (kritisch)
- [ ] LLM-gesteuerte Bewertung pro Segment

## 6. Chat-System

### 6.1 Chat-Container
- [ ] Overlay √ºber Audio-Player und Buttons
- [ ] Dunkelgrauer Container mit Transparenz
- [ ] Eigener Scrollbereich
- [ ] Toggle-Funktion (√∂ffnen/schlie√üen)

### 6.2 Nachrichten-Design
**MuDiKo-KI-Assistent (Links):**
- [ ] Name: "MuDiKo-KI-Assistent"
- [ ] Vertikale Linie in Feedback-Farbe (gr√ºn/orange/rot)
- [ ] Hellgrauer Container mit wei√üer Schrift

**Sch√ºler (Rechts):**
- [ ] Name: "Sch√ºler"
- [ ] Vertikale Linie in MuDiKo-Pink
- [ ] Hellgrauer Container mit wei√üer Schrift

### 6.3 Chat-Funktionalit√§t
- [ ] Eingabefeld f√ºr Sch√ºler-Nachrichten
- [ ] Send-Button
- [ ] LLM-API Integration f√ºr Antworten
- [ ] Message-History pro Segment
- [ ] Auto-Scroll zu neuesten Nachrichten

## 7. LLM-Prompting-System

### 7.1 Overall-Prompt Template
```
Du bist MuDiKo-KI-Assistent, ein spezialisierter Musik-Feedback-Assistent.
Basierend auf dem analysierten Musik-Prompt und den identifizierten Segmenten,
generiere segment-spezifisches Feedback.

Aufgaben:
1. Bewerte jedes Segment (gut/neutral/kritisch)
2. Generiere konstruktives Feedback pro Segment
3. Beantworte Sch√ºler-Nachfragen segment-spezifisch
4. Bleibe motivierend und p√§dagogisch wertvoll
```

### 7.2 Segment-Prompt Generation
- [ ] Basis-Prompt + Segment-spezifische Informationen
- [ ] Zeitstempel-Integration
- [ ] Kontext aus Original-Prompt
- [ ] Feedback-Bewertung f√ºr UI-Darstellung

## 8. Responsive Design & Accessibility
- [ ] Mobile-First Approach
- [ ] Touch-friendly Button-Gr√∂√üen
- [ ] Keyboard-Navigation Support
- [ ] Screen-Reader Kompatibilit√§t
- [ ] Performance-Optimierung f√ºr Audio-Playback

## 9. Error Handling & Fallbacks
- [ ] LLM-API Fehlerbehandlung
- [ ] Audio-Loading Fehlerbehandlung
- [ ] Graceful Degradation bei Feature-Flag disabled
- [ ] Loading States f√ºr alle Async-Operationen

## 10. Testing & Integration
- [ ] Unit Tests f√ºr neue Komponenten
- [ ] Integration Tests f√ºr LLM-Pipeline
- [ ] User Testing der Chat-Funktionalit√§t
- [ ] Performance Tests mit verschiedenen Audio-Dateien

## 11. Schrittweise Implementierung

### Phase 1: Grundstruktur





1. Feature-Flag Setup
2. PersonalizationPage Button hinzuf√ºgen
3. LLMFeedbackPrototype Seite erstellen (ohne LLM)
4. Audio-Player Integration

### Phase 2: Segment-System
1. Backend Segment-Analyse
2. Segment-Buttons generieren
3. Farb-/Emoji-System implementieren

### Phase 3: Chat-System
1. Chat-Container und UI
2. Nachrichten-Design implementieren
3. Basic Chat-Funktionalit√§t

### Phase 4: LLM-Integration
1. Overall-Prompt System
2. LLM-API Integration
3. Feedback-Generierung und -Bewertung

### Phase 5: Polish & Testing
1. Responsive Design verfeinern
2. Error Handling implementieren
3. Testing und Bug-Fixes

## Konfiguration f√ºr Feature-Toggle
```javascript
// config/features.js
export const FEATURES = {
  LLM_FEEDBACK_PROTOTYPE: process.env.ENABLE_LLM_PROTOTYPE === 'true' || false
};
```

Dieser Plan erm√∂glicht eine schrittweise Implementierung mit der M√∂glichkeit, 
jederzeit zum urspr√ºnglichen Zustand zur√ºckzukehren.